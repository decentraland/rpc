/* eslint-disable */
import Long from "long"
import * as _m0 from "protobufjs/minimal"

export const protobufPackage = ""

/** THIS FILE IS AUTOGENERATED */

export enum RpcMessageTypes {
  RpcMessageTypes_EMPTY = 0,
  RpcMessageTypes_REQUEST = 1,
  RpcMessageTypes_RESPONSE = 2,
  RpcMessageTypes_STREAM_MESSAGE = 3,
  RpcMessageTypes_STREAM_ACK = 4,
  RpcMessageTypes_CREATE_PORT = 5,
  RpcMessageTypes_CREATE_PORT_RESPONSE = 6,
  RpcMessageTypes_REQUEST_MODULE = 7,
  RpcMessageTypes_REQUEST_MODULE_RESPONSE = 8,
  RpcMessageTypes_REMOTE_ERROR_RESPONSE = 9,
  RpcMessageTypes_DESTROY_PORT = 10,
  RpcMessageTypes_SERVER_READY = 11,
  UNRECOGNIZED = -1,
}

export function rpcMessageTypesFromJSON(object: any): RpcMessageTypes {
  switch (object) {
    case 0:
    case "RpcMessageTypes_EMPTY":
      return RpcMessageTypes.RpcMessageTypes_EMPTY
    case 1:
    case "RpcMessageTypes_REQUEST":
      return RpcMessageTypes.RpcMessageTypes_REQUEST
    case 2:
    case "RpcMessageTypes_RESPONSE":
      return RpcMessageTypes.RpcMessageTypes_RESPONSE
    case 3:
    case "RpcMessageTypes_STREAM_MESSAGE":
      return RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE
    case 4:
    case "RpcMessageTypes_STREAM_ACK":
      return RpcMessageTypes.RpcMessageTypes_STREAM_ACK
    case 5:
    case "RpcMessageTypes_CREATE_PORT":
      return RpcMessageTypes.RpcMessageTypes_CREATE_PORT
    case 6:
    case "RpcMessageTypes_CREATE_PORT_RESPONSE":
      return RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE
    case 7:
    case "RpcMessageTypes_REQUEST_MODULE":
      return RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE
    case 8:
    case "RpcMessageTypes_REQUEST_MODULE_RESPONSE":
      return RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE
    case 9:
    case "RpcMessageTypes_REMOTE_ERROR_RESPONSE":
      return RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE
    case 10:
    case "RpcMessageTypes_DESTROY_PORT":
      return RpcMessageTypes.RpcMessageTypes_DESTROY_PORT
    case 11:
    case "RpcMessageTypes_SERVER_READY":
      return RpcMessageTypes.RpcMessageTypes_SERVER_READY
    case -1:
    case "UNRECOGNIZED":
    default:
      return RpcMessageTypes.UNRECOGNIZED
  }
}

export function rpcMessageTypesToJSON(object: RpcMessageTypes): string {
  switch (object) {
    case RpcMessageTypes.RpcMessageTypes_EMPTY:
      return "RpcMessageTypes_EMPTY"
    case RpcMessageTypes.RpcMessageTypes_REQUEST:
      return "RpcMessageTypes_REQUEST"
    case RpcMessageTypes.RpcMessageTypes_RESPONSE:
      return "RpcMessageTypes_RESPONSE"
    case RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE:
      return "RpcMessageTypes_STREAM_MESSAGE"
    case RpcMessageTypes.RpcMessageTypes_STREAM_ACK:
      return "RpcMessageTypes_STREAM_ACK"
    case RpcMessageTypes.RpcMessageTypes_CREATE_PORT:
      return "RpcMessageTypes_CREATE_PORT"
    case RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE:
      return "RpcMessageTypes_CREATE_PORT_RESPONSE"
    case RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE:
      return "RpcMessageTypes_REQUEST_MODULE"
    case RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE:
      return "RpcMessageTypes_REQUEST_MODULE_RESPONSE"
    case RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE:
      return "RpcMessageTypes_REMOTE_ERROR_RESPONSE"
    case RpcMessageTypes.RpcMessageTypes_DESTROY_PORT:
      return "RpcMessageTypes_DESTROY_PORT"
    case RpcMessageTypes.RpcMessageTypes_SERVER_READY:
      return "RpcMessageTypes_SERVER_READY"
    default:
      return "UNKNOWN"
  }
}

export interface RpcMessageHeader {
  messageIdentifier: number
}

export interface CreatePort {
  messageIdentifier: number
  portName: string
}

export interface CreatePortResponse {
  messageIdentifier: number
  portId: number
}

export interface RequestModule {
  messageIdentifier: number
  portId: number
  moduleName: string
}

export interface RequestModuleResponse {
  messageIdentifier: number
  portId: number
  procedures: ModuleProcedure[]
}

export interface DestroyPort {
  messageIdentifier: number
  portId: number
}

export interface ModuleProcedure {
  procedureId: number
  procedureName: string
}

export interface Request {
  messageIdentifier: number
  portId: number
  procedureId: number
  payload: Uint8Array
}

export interface RemoteError {
  messageIdentifier: number
  errorCode: number
  errorMessage: string
}

export interface Response {
  messageIdentifier: number
  payload: Uint8Array
}

export interface StreamMessage {
  messageIdentifier: number
  portId: number
  sequenceId: number
  payload: Uint8Array
  closed: boolean
  ack: boolean
}

function createBaseRpcMessageHeader(): RpcMessageHeader {
  return { messageIdentifier: 0 }
}

export const RpcMessageHeader = {
  encode(message: RpcMessageHeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RpcMessageHeader {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRpcMessageHeader()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): RpcMessageHeader {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
    }
  },

  toJSON(message: RpcMessageHeader): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<RpcMessageHeader>, I>>(object: I): RpcMessageHeader {
    const message = createBaseRpcMessageHeader()
    message.messageIdentifier = object.messageIdentifier ?? 0
    return message
  },
}

function createBaseCreatePort(): CreatePort {
  return { messageIdentifier: 0, portName: "" }
}

export const CreatePort = {
  encode(message: CreatePort, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    if (message.portName !== "") {
      writer.uint32(34).string(message.portName)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePort {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCreatePort()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        case 4:
          message.portName = reader.string()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): CreatePort {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
      portName: isSet(object.portName) ? String(object.portName) : "",
    }
  },

  toJSON(message: CreatePort): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    message.portName !== undefined && (obj.portName = message.portName)
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<CreatePort>, I>>(object: I): CreatePort {
    const message = createBaseCreatePort()
    message.messageIdentifier = object.messageIdentifier ?? 0
    message.portName = object.portName ?? ""
    return message
  },
}

function createBaseCreatePortResponse(): CreatePortResponse {
  return { messageIdentifier: 0, portId: 0 }
}

export const CreatePortResponse = {
  encode(message: CreatePortResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    if (message.portId !== 0) {
      writer.uint32(21).fixed32(message.portId)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePortResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCreatePortResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        case 2:
          message.portId = reader.fixed32()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): CreatePortResponse {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
      portId: isSet(object.portId) ? Number(object.portId) : 0,
    }
  },

  toJSON(message: CreatePortResponse): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    message.portId !== undefined && (obj.portId = Math.round(message.portId))
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<CreatePortResponse>, I>>(object: I): CreatePortResponse {
    const message = createBaseCreatePortResponse()
    message.messageIdentifier = object.messageIdentifier ?? 0
    message.portId = object.portId ?? 0
    return message
  },
}

function createBaseRequestModule(): RequestModule {
  return { messageIdentifier: 0, portId: 0, moduleName: "" }
}

export const RequestModule = {
  encode(message: RequestModule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    if (message.portId !== 0) {
      writer.uint32(21).fixed32(message.portId)
    }
    if (message.moduleName !== "") {
      writer.uint32(34).string(message.moduleName)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestModule {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRequestModule()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        case 2:
          message.portId = reader.fixed32()
          break
        case 4:
          message.moduleName = reader.string()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): RequestModule {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
      portId: isSet(object.portId) ? Number(object.portId) : 0,
      moduleName: isSet(object.moduleName) ? String(object.moduleName) : "",
    }
  },

  toJSON(message: RequestModule): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    message.portId !== undefined && (obj.portId = Math.round(message.portId))
    message.moduleName !== undefined && (obj.moduleName = message.moduleName)
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<RequestModule>, I>>(object: I): RequestModule {
    const message = createBaseRequestModule()
    message.messageIdentifier = object.messageIdentifier ?? 0
    message.portId = object.portId ?? 0
    message.moduleName = object.moduleName ?? ""
    return message
  },
}

function createBaseRequestModuleResponse(): RequestModuleResponse {
  return { messageIdentifier: 0, portId: 0, procedures: [] }
}

export const RequestModuleResponse = {
  encode(message: RequestModuleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    if (message.portId !== 0) {
      writer.uint32(21).fixed32(message.portId)
    }
    for (const v of message.procedures) {
      ModuleProcedure.encode(v!, writer.uint32(42).fork()).ldelim()
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestModuleResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRequestModuleResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        case 2:
          message.portId = reader.fixed32()
          break
        case 5:
          message.procedures.push(ModuleProcedure.decode(reader, reader.uint32()))
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): RequestModuleResponse {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
      portId: isSet(object.portId) ? Number(object.portId) : 0,
      procedures: Array.isArray(object?.procedures)
        ? object.procedures.map((e: any) => ModuleProcedure.fromJSON(e))
        : [],
    }
  },

  toJSON(message: RequestModuleResponse): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    message.portId !== undefined && (obj.portId = Math.round(message.portId))
    if (message.procedures) {
      obj.procedures = message.procedures.map((e) => (e ? ModuleProcedure.toJSON(e) : undefined))
    } else {
      obj.procedures = []
    }
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<RequestModuleResponse>, I>>(object: I): RequestModuleResponse {
    const message = createBaseRequestModuleResponse()
    message.messageIdentifier = object.messageIdentifier ?? 0
    message.portId = object.portId ?? 0
    message.procedures = object.procedures?.map((e) => ModuleProcedure.fromPartial(e)) || []
    return message
  },
}

function createBaseDestroyPort(): DestroyPort {
  return { messageIdentifier: 0, portId: 0 }
}

export const DestroyPort = {
  encode(message: DestroyPort, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    if (message.portId !== 0) {
      writer.uint32(21).fixed32(message.portId)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestroyPort {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseDestroyPort()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        case 2:
          message.portId = reader.fixed32()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): DestroyPort {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
      portId: isSet(object.portId) ? Number(object.portId) : 0,
    }
  },

  toJSON(message: DestroyPort): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    message.portId !== undefined && (obj.portId = Math.round(message.portId))
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<DestroyPort>, I>>(object: I): DestroyPort {
    const message = createBaseDestroyPort()
    message.messageIdentifier = object.messageIdentifier ?? 0
    message.portId = object.portId ?? 0
    return message
  },
}

function createBaseModuleProcedure(): ModuleProcedure {
  return { procedureId: 0, procedureName: "" }
}

export const ModuleProcedure = {
  encode(message: ModuleProcedure, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.procedureId !== 0) {
      writer.uint32(13).fixed32(message.procedureId)
    }
    if (message.procedureName !== "") {
      writer.uint32(18).string(message.procedureName)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModuleProcedure {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseModuleProcedure()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.procedureId = reader.fixed32()
          break
        case 2:
          message.procedureName = reader.string()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): ModuleProcedure {
    return {
      procedureId: isSet(object.procedureId) ? Number(object.procedureId) : 0,
      procedureName: isSet(object.procedureName) ? String(object.procedureName) : "",
    }
  },

  toJSON(message: ModuleProcedure): unknown {
    const obj: any = {}
    message.procedureId !== undefined && (obj.procedureId = Math.round(message.procedureId))
    message.procedureName !== undefined && (obj.procedureName = message.procedureName)
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<ModuleProcedure>, I>>(object: I): ModuleProcedure {
    const message = createBaseModuleProcedure()
    message.procedureId = object.procedureId ?? 0
    message.procedureName = object.procedureName ?? ""
    return message
  },
}

function createBaseRequest(): Request {
  return { messageIdentifier: 0, portId: 0, procedureId: 0, payload: new Uint8Array() }
}

export const Request = {
  encode(message: Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    if (message.portId !== 0) {
      writer.uint32(21).fixed32(message.portId)
    }
    if (message.procedureId !== 0) {
      writer.uint32(37).fixed32(message.procedureId)
    }
    if (message.payload.length !== 0) {
      writer.uint32(50).bytes(message.payload)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Request {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        case 2:
          message.portId = reader.fixed32()
          break
        case 4:
          message.procedureId = reader.fixed32()
          break
        case 6:
          message.payload = reader.bytes()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): Request {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
      portId: isSet(object.portId) ? Number(object.portId) : 0,
      procedureId: isSet(object.procedureId) ? Number(object.procedureId) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
    }
  },

  toJSON(message: Request): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    message.portId !== undefined && (obj.portId = Math.round(message.portId))
    message.procedureId !== undefined && (obj.procedureId = Math.round(message.procedureId))
    message.payload !== undefined &&
      (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()))
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<Request>, I>>(object: I): Request {
    const message = createBaseRequest()
    message.messageIdentifier = object.messageIdentifier ?? 0
    message.portId = object.portId ?? 0
    message.procedureId = object.procedureId ?? 0
    message.payload = object.payload ?? new Uint8Array()
    return message
  },
}

function createBaseRemoteError(): RemoteError {
  return { messageIdentifier: 0, errorCode: 0, errorMessage: "" }
}

export const RemoteError = {
  encode(message: RemoteError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    if (message.errorCode !== 0) {
      writer.uint32(21).fixed32(message.errorCode)
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoteError {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRemoteError()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        case 2:
          message.errorCode = reader.fixed32()
          break
        case 3:
          message.errorMessage = reader.string()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): RemoteError {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
      errorCode: isSet(object.errorCode) ? Number(object.errorCode) : 0,
      errorMessage: isSet(object.errorMessage) ? String(object.errorMessage) : "",
    }
  },

  toJSON(message: RemoteError): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    message.errorCode !== undefined && (obj.errorCode = Math.round(message.errorCode))
    message.errorMessage !== undefined && (obj.errorMessage = message.errorMessage)
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<RemoteError>, I>>(object: I): RemoteError {
    const message = createBaseRemoteError()
    message.messageIdentifier = object.messageIdentifier ?? 0
    message.errorCode = object.errorCode ?? 0
    message.errorMessage = object.errorMessage ?? ""
    return message
  },
}

function createBaseResponse(): Response {
  return { messageIdentifier: 0, payload: new Uint8Array() }
}

export const Response = {
  encode(message: Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    if (message.payload.length !== 0) {
      writer.uint32(50).bytes(message.payload)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Response {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        case 6:
          message.payload = reader.bytes()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): Response {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
    }
  },

  toJSON(message: Response): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    message.payload !== undefined &&
      (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()))
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<Response>, I>>(object: I): Response {
    const message = createBaseResponse()
    message.messageIdentifier = object.messageIdentifier ?? 0
    message.payload = object.payload ?? new Uint8Array()
    return message
  },
}

function createBaseStreamMessage(): StreamMessage {
  return { messageIdentifier: 0, portId: 0, sequenceId: 0, payload: new Uint8Array(), closed: false, ack: false }
}

export const StreamMessage = {
  encode(message: StreamMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageIdentifier !== 0) {
      writer.uint32(13).fixed32(message.messageIdentifier)
    }
    if (message.portId !== 0) {
      writer.uint32(21).fixed32(message.portId)
    }
    if (message.sequenceId !== 0) {
      writer.uint32(37).fixed32(message.sequenceId)
    }
    if (message.payload.length !== 0) {
      writer.uint32(50).bytes(message.payload)
    }
    if (message.closed === true) {
      writer.uint32(56).bool(message.closed)
    }
    if (message.ack === true) {
      writer.uint32(64).bool(message.ack)
    }
    return writer
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamMessage {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseStreamMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1:
          message.messageIdentifier = reader.fixed32()
          break
        case 2:
          message.portId = reader.fixed32()
          break
        case 4:
          message.sequenceId = reader.fixed32()
          break
        case 6:
          message.payload = reader.bytes()
          break
        case 7:
          message.closed = reader.bool()
          break
        case 8:
          message.ack = reader.bool()
          break
        default:
          reader.skipType(tag & 7)
          break
      }
    }
    return message
  },

  fromJSON(object: any): StreamMessage {
    return {
      messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,
      portId: isSet(object.portId) ? Number(object.portId) : 0,
      sequenceId: isSet(object.sequenceId) ? Number(object.sequenceId) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
      closed: isSet(object.closed) ? Boolean(object.closed) : false,
      ack: isSet(object.ack) ? Boolean(object.ack) : false,
    }
  },

  toJSON(message: StreamMessage): unknown {
    const obj: any = {}
    message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier))
    message.portId !== undefined && (obj.portId = Math.round(message.portId))
    message.sequenceId !== undefined && (obj.sequenceId = Math.round(message.sequenceId))
    message.payload !== undefined &&
      (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()))
    message.closed !== undefined && (obj.closed = message.closed)
    message.ack !== undefined && (obj.ack = message.ack)
    return obj
  },

  fromPartial<I extends Exact<DeepPartial<StreamMessage>, I>>(object: I): StreamMessage {
    const message = createBaseStreamMessage()
    message.messageIdentifier = object.messageIdentifier ?? 0
    message.portId = object.portId ?? 0
    message.sequenceId = object.sequenceId ?? 0
    message.payload = object.payload ?? new Uint8Array()
    message.closed = object.closed ?? false
    message.ack = object.ack ?? false
    return message
  },
}

declare var self: any | undefined
declare var window: any | undefined
declare var global: any | undefined
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis
  if (typeof self !== "undefined") return self
  if (typeof window !== "undefined") return window
  if (typeof global !== "undefined") return global
  throw "Unable to locate global object"
})()

const atob: (b64: string) => string =
  globalThis.atob || ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"))
function bytesFromBase64(b64: string): Uint8Array {
  const bin = atob(b64)
  const arr = new Uint8Array(bin.length)
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i)
  }
  return arr
}

const btoa: (bin: string) => string =
  globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"))
function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = []
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte))
  })
  return btoa(bin.join(""))
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<Exclude<keyof I, KeysOfUnion<P>>, never>

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any
  _m0.configure()
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined
}
