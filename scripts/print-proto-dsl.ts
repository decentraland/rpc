import { isProtoEnum, isProtoMessage, ProtoEnum, ProtoField, ProtoMessage } from "./proto-dsl"
import camelCase from "camelcase"

export function generateProtoFile(names: Map<string, ProtoMessage | ProtoEnum>): string {
  const parts: string[] = [`// THIS FILE IS AUTOGENERATED`, `syntax = "proto3";`]

  for (const [name, value] of names) {
    if (isProtoMessage(value)) {
      parts.push(`message ${name} {`)

      value.fields.sort((a, b) => (a.number > b.number ? 1 : -1))

      for (const field of value.fields) {
        parts.push(`  ${field.repeated ? "repeated " : ""}${field.type}\t${field.name} = ${field.number};`)
      }

      parts.push(`}\n`)
    } else if (isProtoEnum(value)) {
      parts.push(`enum ${name} {`)
      for (const key in value.values) {
        parts.push(`  ${name}_${key} = ${value.values[key]};`)
      }
      parts.push(`}\n`)
    }
  }

  return parts.join("\n")
}

function mapTypescriptType(incomingType: string): string {
  switch (incomingType) {
    case "bytes":
      return "Uint8Array"
    case "bool":
      return "boolean"
  }
  return incomingType
}

function unaryReader(type: ProtoField): string {
  switch (type.type) {
    case "fixed32":
      return "d.readUint32($)"
    case "string":
      return "_readString($)"
    case "bytes":
      return "_readBytes($)"
    case "bool":
      return "d.readUint8($) != 0"
  }
  return `read${type.type}($)`
}

function getReader(type: ProtoField): string {
  if (type.repeated) {
    return `_readArray($, ($) => ${unaryReader(type)})`
  }
  return unaryReader(type)
}

function unaryWriter(type: ProtoField, valueName: string): string {
  const accessor = valueName
  switch (type.type) {
    case `fixed32`:
      return `e.writeUint32($, ${accessor})`
    case `string`:
      return `_writeString($, ${accessor})`
    case `bytes`:
      return `_writeBytes($, ${accessor})`
    case `bool`:
      return `e.writeUint8($, ${accessor} ? 1 : 0)`
  }
  return `write${type.type}($, ${accessor})`
}

function getWriter(type: ProtoField, accessorName: string): string {
  if (type.repeated) {
    return `_writeArray($, ($, elem) => ${unaryWriter(type, "elem")}, ${accessorName})`
  }
  return unaryWriter(type, accessorName)
}

export function generateTsProtocol(names: Map<string, ProtoMessage | ProtoEnum>): string {
  const parts: string[] = [
    `// THIS FILE IS AUTOGENERATED`,
    `import * as e from '../encdec/encoding'`,
    `import * as d from '../encdec/decoding'`,
    `export type fixed32 = number\n`,
    `function _readArray<T>($: d.Decoder, reader: ($: d.Decoder) => T): Array<T> {`,
    `  const len = d.readUint32($); const ret: T[] = [];`,
    `  for(let i = 0; i < len; i++) ret.push(reader($));`,
    `  return ret;`,
    `}`,
    `function _readString($: d.Decoder) {`,
    `  return d.readVarString($);`,
    `}`,
    `function _readBytes($: d.Decoder): Uint8Array {`,
    `  return d.readVarUint8Array($);`,
    `}`,

    `function _writeArray<T>($: e.Encoder, writer: ($: e.Encoder, value: T) => void, array: T[]) {`,
    `  e.writeUint32($, array.length);`,
    `  for(let element of array) writer($, element);`,
    `}`,
    `function _writeString($: e.Encoder, value: string) {`,
    `  e.writeVarString($, value);`,
    `}`,
    `function _writeBytes($: e.Encoder, value: Uint8Array) {`,
    `  e.writeVarUint8Array($, value);`,
    `}`,
  ]

  for (const [name, value] of names) {
    if (isProtoMessage(value)) {
      const fields = value.fields.sort((a, b) => (a.number > b.number ? 1 : -1))

      parts.push(`export type ${name} = {`)
      for (const field of fields) {
        const tsType = mapTypescriptType(field.type)
        parts.push(`  ${camelCase(field.name)}: ${field.repeated ? "Array<" + tsType + ">" : tsType}`)
      }
      parts.push(`}\n`)

      parts.push(`export function write${name}($: e.Encoder, value: ${name}) {`)
      for (const field of fields) {
        parts.push(`  ${getWriter(field, `value[${JSON.stringify(camelCase(field.name))}]`)};`)
      }
      parts.push(`}\n`)

      parts.push(`export function read${name}($: d.Decoder): ${name} {`)
      parts.push(`  return {`)
      for (const field of fields) {
        parts.push(`    ${camelCase(field.name)}: ${getReader(field)},`)
      }
      parts.push(`  }`)
      parts.push(`}\n`)
    } else if (isProtoEnum(value)) {
      parts.push(`export const enum ${name} {`)
      for (const key in value.values) {
        parts.push(`  ${key} = ${value.values[key]},`)
      }
      parts.push(`}\n`)
    }
  }

  return parts.join("\n")
}
