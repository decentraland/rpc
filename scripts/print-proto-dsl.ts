import { isProtoEnum, isProtoMessage, ProtoEnum, ProtoField, ProtoMessage } from "./proto-dsl"
import camelCase from "camelcase"

export function generateProtoFile(names: Map<string, ProtoMessage | ProtoEnum>): string {
  const parts: string[] = [`// THIS FILE IS AUTOGENERATED`, `syntax = "proto3";`]

  for (const [name, value] of names) {
    if (isProtoMessage(value)) {
      parts.push(`message ${name} {`)

      value.fields.sort((a, b) => (a.number > b.number ? 1 : -1))

      for (const field of value.fields) {
        parts.push(`  ${field.repeated ? "repeated " : ""}${field.type}\t${field.name} = ${field.number};`)
      }

      parts.push(`}\n`)
    } else if (isProtoEnum(value)) {
      parts.push(`enum ${name} {`)
      for (const key in value.values) {
        parts.push(`  ${name}_${key} = ${value.values[key]};`)
      }
      parts.push(`}\n`)
    }
  }

  return parts.join("\n")
}

function mapTypescriptType(incomingType: string): string {
  switch (incomingType) {
    case "bytes":
      return "Uint8Array"
    case "bool":
      return "boolean"
  }
  return incomingType
}

function unaryReader(type: ProtoField): string {
  switch (type.type) {
    case "fixed32":
      return "bb.readInt32()"
    case "string":
      return "_readString(bb)"
    case "bytes":
      return "_readBytes(bb)"
    case "bool":
      return "bb.readByte() != 0"
  }
  return `read${type.type}(bb)`
}

function getReader(type: ProtoField): string {
  if (type.repeated) {
    return `_readArray(bb, (bb) => ${unaryReader(type)})`
  }
  return unaryReader(type)
}

function unaryWriter(type: ProtoField, valueName: string): string {
  const accessor = valueName
  switch (type.type) {
    case `fixed32`:
      return `bb.writeInt32(${accessor})`
    case `string`:
      return `_writeString(bb, ${accessor})`
    case `bytes`:
      return `_writeBytes(bb, ${accessor})`
    case `bool`:
      return `bb.writeByte(${accessor} ? 1 : 0)`
  }
  return `write${type.type}(bb, ${accessor})`
}

function getWriter(type: ProtoField, accessorName: string): string {
  if (type.repeated) {
    return `_writeArray(bb, (bb, elem) => ${unaryWriter(type, "elem")}, ${accessorName})`
  }
  return unaryWriter(type, accessorName)
}

export function generateTsProtocol(names: Map<string, ProtoMessage | ProtoEnum>): string {
  const parts: string[] = [
    `// THIS FILE IS AUTOGENERATED`,
    `import ByteBuffer from 'bytebuffer'`,
    `export type fixed32 = number\n`,
    `function _readArray<T>(bb: ByteBuffer, reader: (bb: ByteBuffer) => T): Array<T> {`,
    `  const len = bb.readUint32(); const ret: T[] = [];`,
    `  for(let i = 0; i < len; i++) ret.push(reader(bb));`,
    `  return ret;`,
    `}`,
    `function _readString(bb: ByteBuffer) {`,
    `  const len=bb.readUint32();`,
    `  return bb.readString(len);`,
    `}`,
    `function _readBytes(bb: ByteBuffer): Uint8Array {`,
    `  const len=bb.readUint32();`,
    `  return bb.readBytes(len).buffer;`,
    `}`,

    `function _writeArray<T>(bb: ByteBuffer, writer: (bb: ByteBuffer, value: T) => void, array: T[]) {`,
    `  bb.writeUint32(array.length);`,
    `  for(let element of array) writer(bb, element);`,
    `}`,
    `function _writeString(bb: ByteBuffer, value: string) { // TODO: check encoding and WTF-16`,
    `  bb.writeUint32(value.length);`,
    `  bb.writeString(value);`,
    `}`,
    `function _writeBytes(bb: ByteBuffer, value: Uint8Array) {`,
    `  bb.writeUint32(value.byteLength);`,
    `  bb.writeBytes(value);`,
    `}`,
  ]

  for (const [name, value] of names) {
    if (isProtoMessage(value)) {
      const fields = value.fields.sort((a, b) => (a.number > b.number ? 1 : -1))

      parts.push(`export type ${name} = {`)
      for (const field of fields) {
        const tsType = mapTypescriptType(field.type)
        parts.push(`  ${camelCase(field.name)}: ${field.repeated ? "Array<" + tsType + ">" : tsType}`)
      }
      parts.push(`}\n`)

      parts.push(`export function write${name}(bb: ByteBuffer, value: ${name}) {`)
      for (const field of fields) {
        parts.push(`  ${getWriter(field, `value[${JSON.stringify(camelCase(field.name))}]`)};`)
      }
      parts.push(`}\n`)

      parts.push(`export function read${name}(bb: ByteBuffer): ${name} {`)
      parts.push(`  return {`)
      for (const field of fields) {
        parts.push(`    ${camelCase(field.name)}: ${getReader(field)},`)
      }
      parts.push(`  }`)
      parts.push(`}\n`)
    } else if (isProtoEnum(value)) {
      parts.push(`export const enum ${name} {`)
      for (const key in value.values) {
        parts.push(`  ${key} = ${value.values[key]},`)
      }
      parts.push(`}\n`)
    }
  }

  return parts.join("\n")
}
